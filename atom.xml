<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SYJ个人主页</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-12-16T12:41:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JoYous-SUN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redux-devtools简单使用</title>
    <link href="http://yoursite.com/2016/12/16/redux-devtools%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2016/12/16/redux-devtools简单使用/</id>
    <published>2016-12-16T12:07:16.000Z</published>
    <updated>2016-12-16T12:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><h3 id="Introducing"><a href="#Introducing" class="headerlink" title="Introducing"></a>Introducing</h3><p>redux-devtools 是一个非常棒的工具，它可以让你实时的监控Redux的状态树的Store</p>
</li>
<li><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev redux-devtools</div><div class="line">npm install --save-dev redux-devtools-log-monitor</div><div class="line">npm install --save-dev redux-devtools-dock-monitor</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<ul>
<li><h3 id="Usege"><a href="#Usege" class="headerlink" title="Usege"></a>Usege</h3><p>创建DevTools组件<br>在你的App项目中，通过“Monitor（监视显示）”用createDevTools创建一个DevTools组件。示例用了最常用，最简单的LogMonitor和DockMonitor</p>
</li>
<li><p>containers/DevTools.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;</div><div class="line"></div><div class="line">//从redux-devtools中引入createDevTools</div><div class="line">import &#123; createDevTools &#125; from &apos;redux-devtools&apos;;</div><div class="line"></div><div class="line">//显示包是单独的，要额外指定</div><div class="line">import LogMonitor from &apos;redux-devtools-log-monitor&apos;;</div><div class="line">import DockMonitor from &apos;redux-devtools-dock-monitor&apos;;</div><div class="line"></div><div class="line">//创建DevTools组件</div><div class="line">const DevTools = createDevTools(</div><div class="line">  &lt;DockMonitor toggleVisibilityKey=&apos;ctrl-h&apos;</div><div class="line">               changePositionKey  =&apos;ctrl-q&apos;&gt;</div><div class="line">    &lt;LogMonitor theme=&apos;tomorrow&apos; /&gt;</div><div class="line">  &lt;/DockMonitor&gt;</div><div class="line">);</div><div class="line"></div><div class="line">export default DevTools</div></pre></td></tr></table></figure>
<p>用DevTools.instrument()通过redux的compose来扩展store<br>用createDevTools()创建的DevTools组件有个特殊的静态方法instrument(),它返回一个store的增强器,在开发中你需要在compose中使用。注意：DevTools.instrument()要放在applyMiddleware后，因为你的applyMiddleware可以存在异步行为，为了确保所有的actions显示在store中，所以要放在后面</p>
</li>
<li><p>store/create.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import &#123;createStore,applyMiddleware,compose&#125; from &apos;redux&apos;</div><div class="line">import rootReducer from &apos;./modules/reducers&apos;</div><div class="line"></div><div class="line">import thunk from &apos;./middleware/thunk&apos;</div><div class="line">import DevTools from &apos;../containers/DevTools&apos;</div><div class="line"></div><div class="line">const enhancer = compose(</div><div class="line">  //你要使用的中间件，放在前面</div><div class="line">  applyMiddleware(thunk),</div><div class="line">  //必须的！启用带有monitors（监视显示）的DevTools</div><div class="line">  DevTools.instrument()</div><div class="line">)</div><div class="line"></div><div class="line">export default function createStoreWithMiddleware(initialState)&#123;</div><div class="line">  //注意：仅仅只有redux&gt;=3.1.0支持第三个参数</div><div class="line">  const store = createStore(rootReducer,initialState,enhancer)</div><div class="line">  return store</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Render <devtools> in your App</devtools></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123; render &#125; from &apos;react-dom&apos;;</div><div class="line">import &#123; Provider &#125; from &apos;react-redux&apos;;</div><div class="line">import configureStore from &apos;./store/configureStore&apos;;</div><div class="line">import TodoApp from &apos;./components/Counter&apos;;</div><div class="line"></div><div class="line">//注意，不要直接这样做，要区分开发环境和生产环境</div><div class="line">import DevTools from &apos;./containers/DevTools&apos;;</div><div class="line"></div><div class="line">const store = configureStore();</div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;Counter /&gt;</div><div class="line">      &lt;DevTools /&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &lt;/Provider&gt;</div><div class="line">  document.getElementById(&apos;app&apos;)</div><div class="line">);</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;Introducing&quot;&gt;&lt;a href=&quot;#Introducing&quot; class=&quot;headerlink&quot; title=&quot;Introducing&quot;&gt;&lt;/a&gt;Introducing&lt;/h3&gt;&lt;p&gt;redux-devtools 是一个非常棒的工具，它可以让你实时的监控Redux的状态树的Store&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h3 id=&quot;Installation&quot;&gt;&lt;a href=&quot;#Installation&quot; class=&quot;headerlink&quot; title=&quot;Installation&quot;&gt;&lt;/a&gt;Installation&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install --save-dev redux-devtools&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install --save-dev redux-devtools-log-monitor&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install --save-dev redux-devtools-dock-monitor&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>redux之store</title>
    <link href="http://yoursite.com/2016/12/16/redux%E4%B9%8Bstore/"/>
    <id>http://yoursite.com/2016/12/16/redux之store/</id>
    <published>2016-12-16T12:05:51.000Z</published>
    <updated>2016-12-16T12:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><blockquote>
<p>store 是什么</p>
</blockquote>
<p>store是一个管理state的大对象，并且提供了一系列的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getState(),  //返回state</div><div class="line">dispatch(action),  // 派发一个action</div><div class="line">subscribe()  //订阅监听</div></pre></td></tr></table></figure></p>
<p>通过redux 提供的 createStore,传入reducer函数，我们可以得到一个store对象<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;</div><div class="line">const store = createStore(reducer)</div></pre></td></tr></table></figure>
<blockquote>
<p>简单实现一个createstore函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//这是一个工厂函数，可以创建store</div><div class="line"></div><div class="line">const  createStore = (reducer) =&gt; &#123;</div><div class="line">   let state; // 定义存储的state</div><div class="line">   let listeners = [];</div><div class="line"></div><div class="line">  //  getState的作用很简单就是返回当前是state</div><div class="line">  const  getState = ()=&gt; state;</div><div class="line"></div><div class="line">    //定义一个派发函数</div><div class="line">    //当在外界调用此函数的时候，会修改状态</div><div class="line">  const dispatch = (action)=&gt;&#123;</div><div class="line">      //调用reducer函数修改状态，返回一新的状态并赋值给这个局部状态变量</div><div class="line">      state = reducer(state,action);</div><div class="line">      //依次调用监听函数，通知所有的监听函数</div><div class="line">      listeners.forEach(listener =&gt; listener());</div><div class="line">  &#125;</div><div class="line">   //订阅此状态的函数，当状态发生变化的时候记得调用此监听函数</div><div class="line">  const subscribe = function(listener)&#123;</div><div class="line">      //先把此监听 加到数组中</div><div class="line">      listeners.push(listener);</div><div class="line"></div><div class="line">      //返回一个函数，当调用它的时候将此监听函数从监听数组移除</div><div class="line">      return function()&#123;</div><div class="line">          listeners = listeners.filter(l =&gt; l != listener);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">    //默认调用一次dispatch给state赋一个初始值</div><div class="line">   dispatch();</div><div class="line">  return &#123;</div><div class="line">      getState,</div><div class="line">      dispatch,</div><div class="line">      subscribe</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">let store = createStore(reducer);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意的点</p>
</blockquote>
<p>根据官方的说法，一个应用应该只有一个store，即单一数据源，我们通过合并reducer 来壮大state tree<br>未完</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;store&quot;&gt;&lt;a href=&quot;#store&quot; class=&quot;headerlink&quot; title=&quot;store&quot;&gt;&lt;/a&gt;store&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;store 是什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;store是一个管理state的大对象，并且提供了一系列的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;getState(),  //返回state&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;dispatch(action),  // 派发一个action&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;subscribe()  //订阅监听&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过redux 提供的 createStore,传入reducer函数，我们可以得到一个store对象&lt;br&gt;
    
    </summary>
    
    
      <category term="react redux" scheme="http://yoursite.com/tags/react-redux/"/>
    
  </entry>
  
  <entry>
    <title>Promise笔记</title>
    <link href="http://yoursite.com/2016/12/16/promise%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/16/promise笔记/</id>
    <published>2016-12-16T11:26:57.000Z</published>
    <updated>2016-12-16T12:41:33.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><blockquote>
<p>为什么会有promise</p>
</blockquote>
<p>根据官方的说法，promise的出现是为了解决”callback hell”回调地狱, 将横向的嵌套回调改为可以纵向以then的方式加载执行。</p>
<blockquote>
<p>简介 &amp; 用法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 通过new Promise 得到一个promise的实例，也就是一个普通对象。构造函数需要传一个callback 去定义何时执行resolve，reject 这两个函数</div><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  if(&apos;code&apos;) &#123; // code 可能是异步操作成功判断条件</div><div class="line">    resolve()</div><div class="line">  &#125; else &#123;</div><div class="line">    reject()</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">// then的两个参数(resolve, reject)</div><div class="line">promise.then(function()&#123;</div><div class="line">  console.log(&apos;success&apos;)</div><div class="line">&#125;,function()&#123;</div><div class="line">  console.log(&apos;failure&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>三种状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[PromiseValue]] //内部属性 -- 状态</div><div class="line">//而且这个状态不可随意更改，只跟resolve ，reject函数执行有关</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实例内部有三种状态标示  </p>
<p>Pending 进行中 即构造函数执行开始</p>
<p>Resolved 已成功 resolve函数 执行</p>
<p>Rejected 已失败 reject函数 执行</p>
<p>而且只能由Pending –&gt; Resolved,Pending–&gt;Rejected ,即成功或失败</p>
<p>这个状态变化的条件是由我们控制的。一个请求返回成功状态码… 等等</p>
<ul>
<li>方法</li>
</ul>
<h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h5><p>两个参数 resolve， reject</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">function getPromise (status) &#123;</div><div class="line">   return new Promise(function(resolve, reject) &#123;</div><div class="line">    let time = Date.now()</div><div class="line">    console.log(&apos;time&apos;)</div><div class="line">    setTimeout(()=&gt;&#123;</div><div class="line">       if(status) &#123;</div><div class="line">         resolve(time)</div><div class="line">       &#125; else &#123;</div><div class="line">         reject(new Error(&apos;status error&apos;))</div><div class="line">       &#125;</div><div class="line">    &#125;,1000)    </div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getPromise(1).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;1&apos;,Date.now()-time)</div><div class="line">  return Date.now()-time</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;2&apos;,time)</div><div class="line">  return time</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;3&apos;,time)</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//</div><div class="line">&quot;time&quot;</div><div class="line">&quot;1&quot; 1002</div><div class="line">&quot;2&quot; 1002</div><div class="line">&quot;3&quot; 1002</div><div class="line">//</div><div class="line">// status传0</div><div class="line">getPromise(0).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;1&apos;,Date.now()-time)</div><div class="line">  return Date.now()-time</div><div class="line">&#125;).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;2&apos;,time)</div><div class="line">  return time</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err)</div><div class="line">  return err</div><div class="line">&#125;).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;3&apos;,time)</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err)</div><div class="line">&#125;)</div><div class="line">//</div><div class="line">&quot;time&quot;</div><div class="line">[object Error] &#123; ... &#125; &quot;err&quot;</div><div class="line">&quot;2&quot; [object Error] &#123; ... &#125;</div><div class="line">&quot;3&quot; [object Error] &#123; ... &#125;</div><div class="line">// 很有意思的是第一次promise 异步代码失败</div><div class="line">执行reject, 但是后面的都是执行resolve,而且resolve的参数都已经是error对象了</div></pre></td></tr></table></figure>
<ol>
<li>这里我们定义了一个函数来返回一个promise实例，然后实例可以执行then。只要构造函数执行，里面的代码就会执行，异步代码也会放到异步队列，当异步代码执行完(这里就是我们的setTimeout)，根据我们提供的条件，成功执行resolve，失败就reject。当然条件都是我们自己规定的，比如异步请求的code…</li>
</ol>
<ol>
<li><p>只要异步代码成功，我们的条件成功，就可以无限then。因为then传的resolve，reject 执行完都后，都会返回一个promise实例。另外，如果我们在resolve里return一个新的promise实例，那么这个promise实例将作为新的then的调用者。如果return一个非promise实例，都会作为参数传递给下面的resolve..</p>
</li>
<li><p>无论是成功的结果还是error信息，都会被一级级传递下来。利用此，举个栗子我们有三个请求，每个请求的参数都依赖于上一个请求的结果，用promise就很简洁… 另外收集错误也是可以做到的。</p>
</li>
</ol>
<p>举个栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">var getJson = function (url) &#123;</div><div class="line">  return new Promise(function (resolve, reject) &#123;</div><div class="line">    var xhr = new XMLHttpRequest ()</div><div class="line">    xhr.open(&apos;get&apos;,url)</div><div class="line">    xhr.onreadystatechange = callback</div><div class="line">    xhr.responseType = &apos;json&apos;</div><div class="line">    xhr.send(null)</div><div class="line">    function callback () &#123;</div><div class="line">      if(this.readyState !== 4) return</div><div class="line">      if(this.status === 200) &#123;</div><div class="line">        resolve(this.response)</div><div class="line">      &#125;else&#123;</div><div class="line">        reject(new Error(this.statusText))</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">getJson(&apos;api/list&apos;).then((response)=&gt;&#123;</div><div class="line">    console.log(response)</div><div class="line">    return getJson(response.url)</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err)</div><div class="line">  return err</div><div class="line">&#125;).then((response)=&gt;&#123;</div><div class="line">    console.log(response)</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err)</div><div class="line">&#125;)</div><div class="line">//这个就是典型的第二个请求的参数依赖于第一个请求返回的结果。</div><div class="line"></div><div class="line">业务中还有那种比如两三个请求都成功了，我们才处理，渲染的。用promise都比较好处理</div></pre></td></tr></table></figure>
<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h5><p>Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">getPromise(0).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;1&apos;,Date.now()-time)</div><div class="line">  return Date.now()-time</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).then(null,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).then(null,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>类似于我们上面的例子把后面两个then 的 resolve去掉 改为null.<br>也就是说，当我们需要在第二个then 里面有目的的收集错误的时候，<br>我们可以直接用catch方法，省去then写法的麻烦。<br>类似于这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">getPromise(0).then((time)=&gt;&#123;</div><div class="line">  console.log(&apos;1&apos;,Date.now()-time)</div><div class="line">  return Date.now()-time</div><div class="line">&#125;,(err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).catch((err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">  return err</div><div class="line">&#125;).catch((err)=&gt;&#123;</div><div class="line">  console.log(err,&apos;err&apos;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>当然我们不会写两个catch。这里只是改写一下then。<br>更多详细的直接看es6 入门里面，讲的很详细，因为catch我用的也不是很多<br><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">es6入门阮一峰-promise</a></p>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h5><p>all 的主要用途就是多个请求，同时成功了，再做某事<br>参数是一个数组，数组里面是Promise实例</p>
<blockquote>
<p>注意这个方法是构造函数上的方法，用于将多个Promise实例，包装成一个新的Promise实例</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">两个Promise，请求 1.getExams  2.getQuestion</div><div class="line">Promise.all([getExams(examId), getQuestion(questionId)]).then((exams,questions)=&gt;&#123;</div><div class="line">    console.log(exams,questions)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>应用场景就是我们多个请求都成功，才能做什么。</p>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h5><p>跟all用法类似，都是传多个promise对象。根据race 的意思，我们大概知道是干嘛的了。哪个先完成，就返回哪个的数据。<br>应用场景大概是两个服务器，比较哪个快。但是现在服务器 都会通过nginx 做负载均衡，也不需要前端去关注这些东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Promise.race([getExams(examId), getQuestion(questionId)]).then((data)=&gt;&#123;</div><div class="line">    console.log(data)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>本次笔记记录先到此，其实API 书中都比较清楚了。关键还是项目中的应用。<br>接下来还会去探究promise内部的实现。 自己实现类fetch的方法</p>
<blockquote>
<p>推荐链接</p>
</blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">es6入门阮一峰-promise</a><br><a href="http://javascript.ruanyifeng.com/advanced/promise.html" target="_blank" rel="external">javascript标准参考教材</a><br><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="external">剖析Promise内部结构</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为什么会有promise&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据官方的说法，promise的出现是为了解决”callback hell”回调地狱, 将横向的嵌套回调改为可以纵向以then的方式加载执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简介 &amp;amp; 用法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// 通过new Promise 得到一个promise的实例，也就是一个普通对象。构造函数需要传一个callback 去定义何时执行resolve，reject 这两个函数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var promise = new Promise(function(resolve, reject) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if(&amp;apos;code&amp;apos;) &amp;#123; // code 可能是异步操作成功判断条件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    resolve()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125; else &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    reject()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// then的两个参数(resolve, reject)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;promise.then(function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  console.log(&amp;apos;success&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;,function()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  console.log(&amp;apos;failure&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JavaScript Promise" scheme="http://yoursite.com/tags/JavaScript-Promise/"/>
    
  </entry>
  
  <entry>
    <title>redux之reducer</title>
    <link href="http://yoursite.com/2016/12/15/redux%E4%B9%8Breducer/"/>
    <id>http://yoursite.com/2016/12/15/redux之reducer/</id>
    <published>2016-12-15T05:26:57.000Z</published>
    <updated>2016-12-16T12:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><ul>
<li>为什么叫reducer<br>大概是由于reducer函数都能作为数组的reduce方法的参数，所以叫reducer的吧。</li>
<li>Array中的reduce<br>reduce需要两个参数，一个是回调函数，一个是初始值，没有初始值，会默认把数组第一个当初始值，并从第二个开始<blockquote>
<p>模拟数组的reduce方法</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Array.prototype.reduce = function reduce (callback, init) &#123;</div><div class="line">  var i = 0;</div><div class="line">  if(typeof init === &apos;undefined&apos;) &#123;</div><div class="line">    init = this[0];</div><div class="line">    i = 1;</div><div class="line">  &#125;</div><div class="line">  if(typeof callback !== &apos;function&apos;) &#123;</div><div class="line">    throw new Error(callback + &apos; is not function&apos;)</div><div class="line">  &#125;</div><div class="line">  for( ;i&lt; this.length; i++ ) &#123;</div><div class="line">    init = callback(init, this[i])</div><div class="line">  &#125;</div><div class="line">  return init ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>reduce的使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var ary = [1,2,3];</div><div class="line">console.log(ary.reduce((initialValue, next) =&gt; &#123;</div><div class="line">  console.log(initialValue, next);</div><div class="line">  return next;</div><div class="line">&#125;,0))</div><div class="line">// 01  12  23  3</div></pre></td></tr></table></figure>
<blockquote>
<p>写一个简单的reducer</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function reducer (initialValue, next) &#123;</div><div class="line">  console.log(initialValue, next)</div><div class="line">  switch (next) &#123;</div><div class="line">    case 1:</div><div class="line">      return next;</div><div class="line">      break;</div><div class="line">    default:</div><div class="line">      return initialValue</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">// 这个reducer 判断传入的值next。是1 的话 返回结果是 next 也就是1 ，所以最后结果都是1</div><div class="line">console.log(ary.reduce(reducer))</div><div class="line">// 12  13  1</div></pre></td></tr></table></figure>
<h3 id="reducer在redux中的作用"><a href="#reducer在redux中的作用" class="headerlink" title="reducer在redux中的作用"></a>reducer在redux中的作用</h3><p>reducer的作用就是设计state结构，它可以给定state 的初始值，更重要的是告诉store，根据对应的action如何更新state。 通常我们的store需要多个reducer组合，成为我们最后的state tree</p>
<blockquote>
<p>注意点</p>
</blockquote>
<ul>
<li>保持reducer 的纯净</li>
</ul>
<p>通常我们的reducer是纯函数(pure function) 即固定的输入返回固定的输出，没有副作用，没有API请求… 等等，之后我们说为什么这么做。<br>通常我们在处理业务中，比如请求一个列表的数据并渲染。<br>举个栗子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">const initialState = &#123;</div><div class="line">  code: -1,</div><div class="line">  data: [],</div><div class="line">  isFetching: false</div><div class="line">&#125;;</div><div class="line">//初始化我们的state，也就是没有请求之前，我们根据接口的数据格式做一个模拟</div><div class="line"></div><div class="line">function List(state = initialState, action) &#123;</div><div class="line">  switch (action.type) &#123;</div><div class="line">// 这里的types 通常是我们保存这种常量的一个对象</div><div class="line"></div><div class="line">    case types.FETCH_LIST_SUCCESS:</div><div class="line">      return &#123;...state, data:action.data,isFetching:false&#125;;</div><div class="line">    case types.FETCHING_LIST:</div><div class="line">      return &#123;...state, isFetching: true&#125;</div><div class="line">    case types.FETCH_LIST_FAILURE:</div><div class="line">      return &#123;...state, isFetching:false&#125;;</div><div class="line">    default:</div><div class="line">      return state</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 我们的reducer函数就是根据请求的状态返回不同的数据，但是数据格式是一定的。Fetching就是 请求过程中，比如我们做一个loading效果可能需要这个。然后type是success就是成功我们返回数据。这些请求都放到actions 中了，actions去处理逻辑，数据API，重组数据。只需要传给reducer函数数据结果就ok了。</p>
<blockquote>
<p>为什么要重新返回一个对象。</p>
</blockquote>
<p>我们可以看到reducer函数在拿到数据后通过Object.assign 重新返回一个对象，直接state.data 修改，返回state不行吗？</p>
<p>首先 我们默认的初始state是不能直接改变的，我们的reducer函数 在数据failure的时候 return了默认的state，这个initialState 是不应该被修改的。</p>
<p>另外，我们的react组件 会多次接受store传入props，每一次都应该是一个全新的对象引用，而不是同一个引用。比如我们需要比较两次传入的props，利用componentWillReciveProps（nextProps） 比较this.props 跟nextProps，肯定是需要两个对象空间的，不然是同一个对象引用也就没法比较了。</p>
<p>所以redux 中的reducer 函数要求我们必须返回新的对象state</p>
<p><a href="http://cn.redux.js.org/docs/basics/Reducers.html" target="_blank" rel="external">redux文档-reducer</a></p>
<h3 id="多个reducer组合成我们的state-tree"><a href="#多个reducer组合成我们的state-tree" class="headerlink" title="多个reducer组合成我们的state tree"></a>多个reducer组合成我们的state tree</h3><p>通常我们会引入redux提供的一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import &#123; combineReducers &#125; from &apos;redux&apos;</div></pre></td></tr></table></figure></p>
<p>其实combineReducers做的事情很简单，顾名思义就是合并多个reducer<br>比如我们一个项目有多个reducer但是最后需要合并成一个，然后告诉store生成state tree，再注入Provider组件，先不关注Provider的问题。我们看一下combineReducers的简单实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//首先我们组合得到的reducer仍旧是一个函数</div><div class="line">//这个reducer会整合所有的reducer</div><div class="line">//然后根据我们定义的状态树的格式返回一个大的state tree</div><div class="line">// 根据reducers这个对象的key，取到reducer函数，并传入对应的 state</div><div class="line"></div><div class="line">const combineReducers = function combineReducers (reducers) &#123;</div><div class="line">  return (state = &#123;&#125;, action) &#123;</div><div class="line">    Object.keys(reducers).reduce((initialState, key) =&gt; &#123;</div><div class="line">      initialState[key] = reducers[key](state[key], action)</div><div class="line">      return initialState</div><div class="line">    &#125;,&#123;&#125;)</div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个函数返回一个rootReducer，然后createStore接收rootReducer，在createStore内部会调用一次dispatch(init)，rootReducer 会执行，所有我们制定的reducrs对象中的key 都会被添加到 一个初始化initialState中，遍历将每个子级state添加到initialState 。init的时候，state[key]是undefined，每个reducer函数有初始值 返回。以后的dispatch ，因为有了state tree，state[key]都可以取到值了。</p>
<p>待续…</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;reducer&quot;&gt;&lt;a href=&quot;#reducer&quot; class=&quot;headerlink&quot; title=&quot;reducer&quot;&gt;&lt;/a&gt;reducer&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;为什么叫reducer&lt;br&gt;大概是由于reducer函数都能作为数组的reduce方法的参数，所以叫reducer的吧。&lt;/li&gt;
&lt;li&gt;Array中的reduce&lt;br&gt;reduce需要两个参数，一个是回调函数，一个是初始值，没有初始值，会默认把数组第一个当初始值，并从第二个开始&lt;blockquote&gt;
&lt;p&gt;模拟数组的reduce方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Array.prototype.reduce = function reduce (callback, init) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  var i = 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if(typeof init === &amp;apos;undefined&amp;apos;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init = this[0];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i = 1;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  if(typeof callback !== &amp;apos;function&amp;apos;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    throw new Error(callback + &amp;apos; is not function&amp;apos;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  for( ;i&amp;lt; this.length; i++ ) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init = callback(init, this[i])&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return init ;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="react redux" scheme="http://yoursite.com/tags/react-redux/"/>
    
  </entry>
  
</feed>
